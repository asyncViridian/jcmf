package util;

import javafx.util.Pair;

import java.io.File;
import java.io.FileNotFoundException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

/**
 * This class is designed to ONLY work with the output of cmfinder when used
 * in conjunction with input generated by BlockMerger. No guarantees made for
 * any other Stockholm-type files.
 */
// TODO generalise if possible????
public class StockholmAlignmentBlock {
    private Map<String, Source> sources
            = new HashMap<>();
    private Map<String, Pair<BigInteger, BigInteger>> intervals
            = new HashMap<>();
    private Map<String, BigDecimal> scores
            = new HashMap<>();
    public BigDecimal pairScore;
    public BigDecimal rnaScore;

    // TODO layout the data stored in a Stockholm format file... Add more detail

    /**
     * Constructs a Stockholm alignment block given a filename of a file from
     * pscore output (formatted with a lot of debug output, followed by a
     * segment of Stockholm formatted file, followed by two quality scores.)
     *
     * @param f filename to read
     * @return a StockholmAlignmentBlock that represents the given file
     */
    public static StockholmAlignmentBlock constructFromScore(File f)
            throws FileNotFoundException {
        // TODO improve this...?
        StockholmAlignmentBlock result = new StockholmAlignmentBlock();

        // scan through the file
        Scanner s = new Scanner(f);
        // skip to the stockholm header section
        boolean targetReached = false;
        while (!targetReached && s.hasNextLine()) {
            String line = s.nextLine();
            if (line.contains("#=GF AU")) {
                targetReached = true;
            }
        }
        // consume the newline
        if (s.hasNextLine()) {
            s.nextLine();
        } else {
            System.err.println(f.toString() + " malformat");
            return null;
        }
        // skip past the weights, to the detail section
        targetReached = false;
        while (!targetReached && s.hasNextLine()) {
            String line = s.nextLine();
            if (line.isEmpty()) {
                targetReached = true;
            }
        }
        // read the detail section and input the mappings
        targetReached = false;
        while (!targetReached && s.hasNextLine()) {
            String line = s.nextLine();
            if (line.isEmpty()) {
                targetReached = true;
            } else {
                // we have a GS DE line, so add the mapping
                String[] parts = line.split("\\s+");
                String[] interval = parts[3].split("\\.\\.");
                Source source = new Source(parts[1]);
                result.sources.put(source.species, source);
                result.intervals.put(source.species, new Pair<>(
                        BigInteger.valueOf(Integer.valueOf(interval[0])),
                        BigInteger.valueOf(Integer.valueOf(interval[1]))
                ));
                result.scores.put(source.species,
                                  BigDecimal.valueOf(
                                          Double.valueOf(parts[4])
                                  ));
            }
        }
        // read the alignment section
        // TODO implement more detail in this if necessary
        targetReached = false;
        while (!targetReached && s.hasNextLine()) {
            String line = s.nextLine();
            if (line.equals("//")) {
                targetReached = true;
            } else {
                // TODO actually parse the alignment section in here if needed
            }
        }
        // read the scores
        result.pairScore = BigDecimal.valueOf(
                Double.valueOf(s.nextLine().split(" ")[3])
        );
        result.rnaScore = BigDecimal.valueOf(
                Double.valueOf(s.nextLine().split(" ")[3])
        );
        return result;
    }

    /**
     * Returns true iff the alignment block contains the given species name.
     *
     * @param s the species to look for
     * @return true iff the alignment block contains s
     */
    public boolean containsSpecies(String s) {
        return this.sources.containsKey(s);
    }

    /**
     * Returns the total interval for the given species name. This interval
     * is relative to the CHROMOSOME.
     *
     * @param s the species to look for
     * @return the total interval for the given species
     */
    public Pair<BigInteger, BigInteger> getInterval(String s) {
        Pair<BigInteger, BigInteger> within = this.intervals.get(s);
        Pair<BigInteger, BigInteger> outside = this.sources.get(s).totalSpan;
        return new Pair<>(
                within.getKey().add(outside.getKey()),
                within.getValue().add(outside.getKey())
        );
    }

    /**
     * Returns the relevant chromosome for the given species name.
     *
     * @param s the species to look for
     * @return the chromosome included for the given species
     */
    public String getChromosome(String s) {
        return this.sources.get(s).chr;
    }

    private static class Source {
        /**
         * Species name (i.e. "hg38")
         */
        String species;
        /**
         * Chromosome name (i.e. "chr2")
         */
        String chr;
        /**
         * True iff the strand is positive. (False iff negative.)
         */
        boolean strand;
        /**
         * The total span of the source area.
         */
        Pair<BigInteger, BigInteger> totalSpan;
        /**
         * The component spans of each alignment block that forms the source
         * area.
         */
        List<Pair<BigInteger, BigInteger>> indivSpans;

        /**
         * Reads a BlockMerger-format header line into a Source object
         *
         * @param line BlockMerger-formatted header line
         */
        public Source(String line) {
            String[] parts = line.split(":");
            species = parts[0];
            chr = parts[1];
            strand = parts[2].equals("+");
            String[] fullInterval = parts[3].split("-");
            totalSpan = new Pair<>(
                    BigInteger.valueOf(Integer.valueOf(fullInterval[0])),
                    BigInteger.valueOf(Integer.valueOf(fullInterval[1]))
            );
            String[] allIntervals = parts[4].split(";");
            indivSpans = new ArrayList<>();
            for (int i = 0; i < allIntervals.length; i++) {
                String[] interval = allIntervals[i].split("-");
                indivSpans.add(
                        new Pair<>(
                                BigInteger.valueOf(
                                        Integer.valueOf(interval[0])),
                                BigInteger.valueOf(
                                        Integer.valueOf(interval[1]))
                        )
                );
            }
        }
    }
}
